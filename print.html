<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Oxen</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="init.html">üêÇ üåæ Oxen.ai</a></li><li class="chapter-item expanded "><a href="development.html"><strong aria-hidden="true">1.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="development/build_and_run.html"><strong aria-hidden="true">1.2.</strong> Build & Run</a></li><li class="chapter-item expanded "><a href="development/add_command.html"><strong aria-hidden="true">1.3.</strong> Adding a Command</a></li><li class="chapter-item expanded "><a href="development/testing.html"><strong aria-hidden="true">1.4.</strong> Testing</a></li><li class="chapter-item expanded "><a href="development/release.html"><strong aria-hidden="true">1.5.</strong> Release</a></li></ol></li><li class="chapter-item expanded "><a href="domains.html"><strong aria-hidden="true">2.</strong> Domains</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domains/repositories.html"><strong aria-hidden="true">2.1.</strong> Repositories</a></li><li class="chapter-item expanded "><a href="domains/commits.html"><strong aria-hidden="true">2.2.</strong> Commits</a></li><li class="chapter-item expanded "><a href="domains/branches.html"><strong aria-hidden="true">2.3.</strong> Branches</a></li><li class="chapter-item expanded "><a href="domains/merkle_trees.html"><strong aria-hidden="true">2.4.</strong> Merkle Trees</a></li><li class="chapter-item expanded "><a href="domains/data_frames.html"><strong aria-hidden="true">2.5.</strong> Data Frames</a></li><li class="chapter-item expanded "><a href="domains/schemas.html"><strong aria-hidden="true">2.6.</strong> Schemas</a></li><li class="chapter-item expanded "><a href="domains/diffs.html"><strong aria-hidden="true">2.7.</strong> Diffs</a></li></ol></li><li class="chapter-item expanded "><a href="commands.html"><strong aria-hidden="true">3.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/init.html"><strong aria-hidden="true">3.1.</strong> init</a></li><li class="chapter-item expanded "><a href="commands/config.html"><strong aria-hidden="true">3.2.</strong> config</a></li><li class="chapter-item expanded "><a href="commands/add.html"><strong aria-hidden="true">3.3.</strong> add</a></li><li class="chapter-item expanded "><a href="commands/status.html"><strong aria-hidden="true">3.4.</strong> status</a></li><li class="chapter-item expanded "><a href="commands/commit.html"><strong aria-hidden="true">3.5.</strong> commit</a></li><li class="chapter-item expanded "><a href="commands/checkout.html"><strong aria-hidden="true">3.6.</strong> checkout</a></li><li class="chapter-item expanded "><a href="commands/push.html"><strong aria-hidden="true">3.7.</strong> push</a></li><li class="chapter-item expanded "><a href="commands/clone.html"><strong aria-hidden="true">3.8.</strong> clone</a></li><li class="chapter-item expanded "><a href="commands/pull.html"><strong aria-hidden="true">3.9.</strong> pull</a></li></ol></li><li class="chapter-item expanded "><a href="data_types.html"><strong aria-hidden="true">4.</strong> Data Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data_types/text.html"><strong aria-hidden="true">4.1.</strong> Text</a></li><li class="chapter-item expanded "><a href="data_types/image.html"><strong aria-hidden="true">4.2.</strong> Image</a></li><li class="chapter-item expanded "><a href="data_types/audio.html"><strong aria-hidden="true">4.3.</strong> Audio</a></li><li class="chapter-item expanded "><a href="data_types/video.html"><strong aria-hidden="true">4.4.</strong> Video</a></li><li class="chapter-item expanded "><a href="data_types/tabular.html"><strong aria-hidden="true">4.5.</strong> Tabular</a></li><li class="chapter-item expanded "><a href="data_types/binary.html"><strong aria-hidden="true">4.6.</strong> Binary</a></li></ol></li><li class="chapter-item expanded "><a href="optimizations.html"><strong aria-hidden="true">5.</strong> Optimizations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="optimizations/merkle_tree.html"><strong aria-hidden="true">5.1.</strong> Merkle Tree</a></li><li class="chapter-item expanded "><a href="optimizations/concurrency.html"><strong aria-hidden="true">5.2.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="optimizations/hashing.html"><strong aria-hidden="true">5.3.</strong> Hashing</a></li><li class="chapter-item expanded "><a href="optimizations/compression.html"><strong aria-hidden="true">5.4.</strong> Compression</a></li><li class="chapter-item expanded "><a href="optimizations/networking.html"><strong aria-hidden="true">5.5.</strong> Networking</a></li><li class="chapter-item expanded "><a href="optimizations/remote_workspace.html"><strong aria-hidden="true">5.6.</strong> Remote Workspace</a></li><li class="chapter-item expanded "><a href="optimizations/storage.html"><strong aria-hidden="true">5.7.</strong> Storage</a></li><li class="chapter-item expanded "><a href="optimizations/why_not_git.html"><strong aria-hidden="true">5.8.</strong> Why not extend Git?</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Oxen</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="--oxenai"><a class="header" href="#--oxenai">üêÇ üåæ Oxen.ai</a></h1>
<p>Welcome to the Herd! This is a whirlwind tour of the Oxen.ai codebase. This is an evolving artifact meant to document the tool and codebase.</p>
<p>Each section dives into a different part of the code base as well as the file formats on disk. It is a resource for engineers who want to contribute or extend the tooling, or simply want to learn the inner workings.</p>
<h1 id="what-is-oxen"><a class="header" href="#what-is-oxen">What is Oxen?</a></h1>
<p>Oxen at it's core is a blazing fast data version control tool written in Rust. It is optimized for large machine learning datasets. These datasets could consist of many small files (think an images/ folder for computer vision tasks), a few large files (a collection of timeseries datasets as csvs), or many large files (an LLM pre-training dataset of parquet files).</p>
<p>In the <a href="https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control">Git Book</a> they define "Version Control" as "a system that records changes to a file or set of files over time so that you can recall specific versions later." As a software engineer we typically use tools such as <code>git</code> to version our source code. This allows us to keep every single version of a file so that we can revert back to a previous state and compare changes over time. While <code>git</code> is great for versioning smaller assets such as files in a code base, it struggles to version large datasets.</p>
<h1 id="why-build-oxen"><a class="header" href="#why-build-oxen">Why build Oxen?</a></h1>
<p>As machine learning engineers, we were frustrated with the speed of managing and iterating on datasets that traditionally would not fit well into <code>git</code>. There are extensions to <code>git</code> such as <code>git-lfs</code> but they are like fitting a square peg in a round hole and come with their own issues.</p>
<p>Data versions should be easy to interact with locally, fast to sync to a remote, seamless contribute to, and feel like you have terrabytes accessible at your fingertips by slicing and downloading subsets locally when you need it.</p>
<h1 id="why-write-this-book"><a class="header" href="#why-write-this-book">Why write this book?</a></h1>
<p>"What I cannot create, I do not understand". - Richard Feynman</p>
<p>When it comes to open source contribution and scaling up a software project this is true as well. This book is for developers to get an understanding of the internals, design decisions, and places for improvement in the Oxen.ai code base. Open source is meant to not only be open, but understandable. This is an evolving artifact meant to document the tool and codebase.</p>
<p>The concepts listed in this book are not perfect, but are meant to be a guide posts for the current implementation. Along the way we will point out areas for improvement. If you get to a section and think "Why do we do this? The HAS to be a better way." you are probably right! Check out <a href="./improvements.html">improvements</a> for some ideas we already have, and feel free to add your own.</p>
<h1 id="why-is-oxen-fast"><a class="header" href="#why-is-oxen-fast">Why is Oxen fast?</a></h1>
<p>This is always one of the first questions we get. The simple answer is that there are many <a href="./optimizations.html">optimizations</a> that make Oxen fast. Many are just fundamental computer science concepts but when stacked together make a nice developer experience for iterating on datasets.</p>
<h1 id="why-the-name-oxen"><a class="header" href="#why-the-name-oxen">Why the name Oxen?</a></h1>
<p>"Oxen" üêÇ comes from the fact that the tooling will plow, maintain, and version your data like a good farmer tends to their fields üåæ. During the agricultural revolution the Ox allowed humans to automate the process of plowing fields so they could specialize in higher level tasks. Data is the lifeblood of ML/AI. Let Oxen take care of the grunt work of your infrastructure so you can focus on the higher-level problems that matter to your product.</p>
<h1 id="where-to-start"><a class="header" href="#where-to-start">Where to start?</a></h1>
<p>First you will want to <a href="./development/installation.html">install Oxen</a>. Once you have the tool up and running, we can dive into the implementation details. If you already have the tool up and running, feel free to skip directly to learning about <a href="./domains.html">domains</a> or <a href="./development/add_command.html">how to add a command</a>.</p>
<p>Like any project, let's start by learning how to <a href="./development/build_and_run.html">build and run</a> the codebase.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-development"><a class="header" href="#-development">üõ†Ô∏è Development</a></h1>
<p>There are a few ways of getting up and running with Oxen. The most straightforward way is to install the latest pre-built version of Oxen from the <a href="https://github.com/Oxen-AI/Oxen">open source repository</a>.</p>
<p>If you are actually going to be writing code, it is important to setup your development environment and start writing some code. This section has resources on how to install Oxen from source, how to build and run Oxen, add your first command, unit test, and how to release a new version of Oxen.</p>
<ul>
<li><a href="./development/installation.html">Installation</a></li>
<li><a href="./development/build_and_run.html">Build &amp; Run</a></li>
<li><a href="./development/add_command.html">Adding a Command</a></li>
<li><a href="./development/testing.html">Testing</a></li>
<li><a href="./development/release.html">Release</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-installation"><a class="header" href="#-installation">üßë‚Äçüíª Installation</a></h1>
<p>How to install the Oxen client, server, or python package. If you are a developer, you will want to <a href="development/installation.html#building-from-source">build from source</a>. If you are flying by and learning Oxen you can install the python package or the command line tool from the <a href="https://github.com/Oxen-AI/Oxen/releases">GitHub releases page</a>.</p>
<h2 id="-command-line-tools"><a class="header" href="#-command-line-tools">üíª Command Line Tools</a></h2>
<p>The Oxen client can be installed via <a href="https://brew.sh/">homebrew</a> or by downloading the relevant binaries for Linux or Windows.</p>
<p>You can find the source code for the client <a href="https://github.com/Oxen-AI/Oxen">here</a> and can also build for source for your platform. The continuous integration pipeline will build binaries for each release in <a href="https://github.com/Oxen-AI/Oxen">this repository</a>.</p>
<h3 id="mac"><a class="header" href="#mac">Mac</a></h3>
<pre><code class="language-bash">brew tap Oxen-AI/oxen
</code></pre>
<pre><code class="language-bash">brew install oxen
</code></pre>
<h3 id="ubuntu-latest"><a class="header" href="#ubuntu-latest">Ubuntu Latest</a></h3>
<p>Check the <a href="https://github.com/Oxen-AI/Oxen/releases">GitHub releases page</a> for the latest version of the client and server.</p>
<pre><code class="language-bash">wget https://github.com/Oxen-AI/Oxen/releases/latest/download/oxen-ubuntu-latest.deb
</code></pre>
<pre><code class="language-bash">sudo dpkg -i oxen-ubuntu-latest.deb
</code></pre>
<h3 id="ubuntu-2004"><a class="header" href="#ubuntu-2004">Ubuntu 20.04</a></h3>
<pre><code class="language-bash">wget https://github.com/Oxen-AI/Oxen/releases/latest/download/oxen-ubuntu-20.04.deb
</code></pre>
<pre><code class="language-bash">sudo dpkg -i oxen-ubuntu-20.04.deb
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<pre><code class="language-bash">wget https://github.com/Oxen-AI/Oxen/releases/latest/download/oxen.exe
</code></pre>
<h3 id="other-linux"><a class="header" href="#other-linux">Other Linux</a></h3>
<p>Binaries are coming for other Linux distributions in the future. <a href="development/installation.html#building-from-source">In the meanwhile, you can build from source.</a></p>
<h2 id="-server-install"><a class="header" href="#-server-install">üåé Server Install</a></h2>
<p>The Oxen server binary can be deployed where ever you want to store and backup your data. It is an HTTP server that the client communicates with to enable collaboration.</p>
<h3 id="mac-1"><a class="header" href="#mac-1">Mac</a></h3>
<pre><code class="language-bash">brew tap Oxen-AI/oxen-server
</code></pre>
<pre><code class="language-bash">brew install oxen-server
</code></pre>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<pre><code class="language-bash">wget https://github.com/Oxen-AI/Oxen/releases/latest/download/oxen-server-docker.tar
</code></pre>
<pre><code class="language-bash">docker load &lt; oxen-server-docker.tar
</code></pre>
<pre><code class="language-bash">docker run -d -v /var/oxen/data:/var/oxen/data -p 80:3001 oxen/oxen-server:latest
</code></pre>
<h3 id="ubuntu-latest-1"><a class="header" href="#ubuntu-latest-1">Ubuntu Latest</a></h3>
<pre><code class="language-bash">wget https://github.com/Oxen-AI/Oxen/releases/latest/download/oxen-server-ubuntu-latest.deb
</code></pre>
<pre><code class="language-bash">sudo dpkg -i oxen-server-ubuntu-latest.deb
</code></pre>
<h3 id="ubuntu-2004-1"><a class="header" href="#ubuntu-2004-1">Ubuntu 20.04</a></h3>
<pre><code class="language-bash">wget https://github.com/Oxen-AI/Oxen/releases/latest/download/oxen-server-ubuntu-20.04.deb
</code></pre>
<pre><code class="language-bash">sudo dpkg -i oxen-server-ubuntu-20.04.deb
</code></pre>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<pre><code class="language-bash">wget https://github.com/Oxen-AI/Oxen/releases/latest/download/oxen-server.exe
</code></pre>
<p>To get up and running using the client and server, you can follow the <a href="https://github.com/Oxen-AI/oxen-release">getting started docs</a>.</p>
<h2 id="-python-package"><a class="header" href="#-python-package">üêç Python Package</a></h2>
<pre><code class="language-bash">$ pip install oxenai
</code></pre>
<p>Note that this will only install the Python library and not the command line tool.</p>
<h3 id="installing-oxen-through-jupyter-notebooks-or-google-colab"><a class="header" href="#installing-oxen-through-jupyter-notebooks-or-google-colab">Installing Oxen through Jupyter Notebooks or Google Colab</a></h3>
<p>Create and run this cell:</p>
<pre><code class="language-python">!pip install oxenai
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-build--run"><a class="header" href="#-build--run">üî® Build &amp; Run</a></h1>
<h2 id="install-dependencies"><a class="header" href="#install-dependencies">Install Dependencies</a></h2>
<p>Oxen is purely written in Rust ü¶Ä. You should install the Rust toolchain with rustup: https://www.rust-lang.org/tools/install.</p>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>If you are a developer and want to learn more about adding code or the overall architecture <a href="development/docs/dev/AddLibraryCode.html">start here</a>. Otherwise a quick start to make sure everything is working follows.</p>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<p>To build the command line tool from source, you can follow these steps.</p>
<ol>
<li>
<p>Install rustup via the instructions at https://rustup.rs/</p>
</li>
<li>
<p>Clone the repository https://github.com/Oxen-AI/Oxen</p>
<pre><code class="language-bash">git clone git@github.com:Oxen-AI/Oxen.git
</code></pre>
</li>
<li>
<p><code>cd</code> into the cloned repository</p>
<pre><code class="language-bash">cd Oxen
</code></pre>
</li>
<li>
<p>Run this command (the release flag is recommended but not necessary):</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
</li>
<li>
<p>After the build has finished, the <code>oxen</code> binary will be in <code>Oxen/target/release</code> (or, if you did not use the --release flag, <code>Oxen/target/debug</code>).</p>
<p>Now, to make it usable from a terminal window, you have the option to add it to create a symlink or to add it to your <code>PATH</code>.</p>
</li>
<li>
<p>To add oxen to your <code>PATH</code>:</p>
<p>Add this line to your <code>.bashrc</code> (or equivalent, e.g. <code>.zshrc</code>)</p>
<pre><code class="language-bash">export PATH="$PATH:/path/to/Oxen/target/release"
</code></pre>
</li>
<li>
<p>Alternatively, to create a symlink, run the following command:</p>
<pre><code class="language-bash">sudo ln -s /path/to/Oxen/target/release/oxen /usr/local/bin/oxen
</code></pre>
<p>Note that if you did not use the <code>--release</code> flag when building Oxen, you will have to change the path.</p>
</li>
</ol>
<h2 id="library-cli-server"><a class="header" href="#library-cli-server">Library, CLI, Server</a></h2>
<p>There are three components that are built during <code>cargo build</code> and they are separated into three directories within the <code>src</code> folder.</p>
<pre><code class="language-bash">ls src
</code></pre>
<pre><code>cli/
lib/
server/
</code></pre>
<p>The library is all the shared code between the CLI and Server. This contains the majority of classes and business logic. The CLI and Server are meant to be thin wrappers over the core oxen library functionality.</p>
<p>The library is also used for the <a href="https://github.com/Oxen-AI/oxen-release">Python Client</a> which should also remain a thin wrapper.</p>
<h2 id="speed-up-the-build-process"><a class="header" href="#speed-up-the-build-process">Speed up the build process</a></h2>
<p>You can use
the <a href="https://github.com/rui314/mold">mold</a> linker to speed up builds (The
commercial Mac OS version is <a href="https://github.com/bluewhalesystems/sold">sold</a>).</p>
<p>Assuming you have purchased a license, you can use the following instructions to
install sold and configure cargo to use it for building Oxen:</p>
<pre><code>git clone https://github.com/bluewhalesystems/sold.git

mkdir sold/build
cd sold/build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_COMPILER=c++ ..
cmake --build . -j $(nproc)
sudo cmake --install .
</code></pre>
<p>Then create <code>.cargo/config.toml</code> in your Oxen repo root with the following
content:</p>
<pre><code>[target.x86_64-unknown-linux-gnu]
rustflags = ["-C", "link-arg=-fuse-ld=/usr/local/bin/ld64.mold"]

[target.x86_64-apple-darwin]
rustflags = ["-C", "link-arg=-fuse-ld=/usr/local/bin/ld64.mold"]

</code></pre>
<p><strong>For macOS with Apple Silicon</strong>, you can use the <a href="https://lld.llvm.org/">lld</a> linker.</p>
<pre><code>brew install llvm
</code></pre>
<p>Then create <code>.cargo/config.toml</code> in your Oxen repo root with the following:</p>
<pre><code>[target.aarch64-apple-darwin]
rustflags = [ "-C", "link-arg=-fuse-ld=/opt/homebrew/opt/llvm/bin/ld64.lld", ]

</code></pre>
<h2 id="run-oxen-server"><a class="header" href="#run-oxen-server">Run Oxen-Server</a></h2>
<p>Generate a config file and token to give user access to the server</p>
<pre><code>./target/debug/oxen-server add-user --email ox@oxen.ai --name Ox --output user_config.toml
</code></pre>
<p>Copy the config to the default locations</p>
<pre><code>mkdir ~/.oxen
</code></pre>
<pre><code>mv user_config.toml ~/.oxen/user_config.toml
</code></pre>
<pre><code>cp ~/.oxen/user_config.toml data/test/config/user_config.toml
</code></pre>
<p>Set where you want the data to be synced to. The default sync directory is <code>./data/</code> to change it set the SYNC_DIR environment variable to a path.</p>
<pre><code>export SYNC_DIR=/path/to/sync/dir
</code></pre>
<p>Run the server</p>
<pre><code>./target/debug/oxen-server start
</code></pre>
<p>To run the server with live reload, first install cargo-watch</p>
<pre><code>cargo install cargo-watch
</code></pre>
<p>Then run the server like this</p>
<pre><code>cargo watch -- cargo run --bin oxen-server start
</code></pre>
<h1 id="cli-commands"><a class="header" href="#cli-commands">CLI Commands</a></h1>
<p>Now feel free to try out some CLI commands and see the tool in action!</p>
<pre><code>oxen init .
oxen status
oxen add images/
oxen status
oxen commit -m "added images"
oxen create-remote --name ox/wikipedia --host 0.0.0.0:3001 --scheme http
oxen config --set-remote origin http://localhost:3001/ox/wikipedia
oxen push origin main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-command"><a class="header" href="#adding-a-command">Adding a Command</a></h1>
<p>The main entry point to the Command Line Interface (CLI) is through the <a href="https://github.com/Oxen-AI/Oxen/blob/main/src/cli/src/main.rs">main.rs</a> file. This file is located in the <a href="https://github.com/Oxen-AI/Oxen/tree/main/src/cli/src">Oxen/src/cli/src</a> directory.</p>
<p>Each command is defined in it's own submodule and implements the <code>RunCmd</code> trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
pub trait RunCmd {
    fn name(&amp;self) -&gt; &amp;str;
    fn args(&amp;self) -&gt; clap::Command;
    async fn run(&amp;self, args: &amp;clap::ArgMatches) -&gt; Result&lt;(), OxenError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>These submodules can be found in <code>cmd</code> subdirectory. They are named after the command they implement. For example if you are curious how <code>oxen add</code> is implemented, you would look at <a href="https://github.com/Oxen-AI/Oxen/blob/main/src/cli/src/cmd/add.rs">add.rs</a>.</p>
<h1 id="moo-world"><a class="header" href="#moo-world">Moo' World</a></h1>
<p>To show this pattern in action, let's add a new command to Oxen. This new command will be a simple "Hello, World!" command. The new command will be named "moo" and will be implemented in the <a href="https://github.com/Oxen-AI/Oxen/blob/main/src/cli/src/cmd/moo.rs">moo.rs</a> file.</p>
<p>The command simply prints "moo!" when you run <code>oxen moo</code>. It also takes a <code>--loud</code> flag which makes it print "MOO!" instead of "moo!" if you pass the flag as well as a <code>-n</code> flag which adds extra o's to the end of the string.</p>
<pre><code class="language-bash">$ oxen moo

moo
</code></pre>
<pre><code class="language-bash">oxen moo --loud

MOO!
</code></pre>
<pre><code class="language-bash">oxen moo -n 10

moooooooooo
</code></pre>
<h1 id="name-the-command"><a class="header" href="#name-the-command">Name The Command</a></h1>
<p>The first method to implement in the trait is simply the name of the command. This is used to identify the command in the CLI and in the help menu.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RunCmd for MooCmd {
    fn name(&amp;self) -&gt; &amp;str {
        "moo"
    }
}
<span class="boring">}</span></code></pre></pre>
<h1 id="setup-args"><a class="header" href="#setup-args">Setup Args</a></h1>
<p>The next step is setting up the command line arguments. We use the <a href="https://docs.rs/clap/latest/clap/">clap</a> crate to handle the command line arguments. The arguments are defined in the <code>args</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RunCmd for MooCmd {
    fn args(&amp;self) -&gt; Command {
        // Setups the CLI args for the command
        Command::new(NAME)
            .about("Hello, world! üêÇ")
            .arg(
                Arg::new("number")
                    .long("number")
                    .short('n')
                    .help("How long is the moo?")
                    .default_value("2")
                    .action(clap::ArgAction::Set),
            )
            .arg(
                Arg::new("loud")
                    .long("loud")
                    .short('l')
                    .help("Make the MOO louder.")
                    .action(clap::ArgAction::SetTrue),
            )
    }
}
<span class="boring">}</span></code></pre></pre>
<h1 id="parse-args-and-run-command"><a class="header" href="#parse-args-and-run-command">Parse Args and Run Command</a></h1>
<p>Finally we need to implement the <code>run</code> method which is called when the command is run. The <code>run</code> method is called with the parsed command line arguments.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RunCmd for MooCmd {
    async fn run(&amp;self, args: &amp;clap::ArgMatches) -&gt; Result&lt;(), OxenError&gt; {
        // Parse Args
        let n = args
            .get_one::&lt;String&gt;("number")
            .expect("Must supply number")
            .parse::&lt;usize&gt;()
            .expect("number must be a valid integer.");

        let loud = args.get_flag("loud");
        if loud {
            // Print the moo loudly with -n number of o's
            println!("M{}!", "O".repeat(n));
        } else {
            // Print the moo with -n number of o's
            println!("m{}", "o".repeat(n));
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If a command returns an <code>OxenError</code> it will be handled and printed in the <code>main.rs</code> file and return a non zero exit code.</p>
<h1 id="add-to-cli"><a class="header" href="#add-to-cli">Add to CLI</a></h1>
<p>Now that our command is implemented, we need to add it to the CLI. This is done in the <a href="https://github.com/Oxen-AI/Oxen/blob/main/src/cli/src/main.rs">main.rs</a> file. All you need to do is add a new instance of your command to the <code>cmds</code> vector. The rest of the file is just adding the arguments, parsing them, then calling your <code>run</code> method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cmds: Vec&lt;Box&lt;dyn cmd::RunCmd&gt;&gt; = vec![
    Box::new(cmd::AddCmd),
    Box::new(cmd::MooCmd), // Your new command
];

// ... run commands
<span class="boring">}</span></code></pre></pre>
<p>This should be all you need to get Oxen to go "MOO!". Let's build and run.</p>
<pre><code class="language-bash">cargo build
./target/debug/oxen moo --help
</code></pre>
<p>You will see the help menu for your new command.</p>
<pre><code class="language-bash">Hello, world! üêÇ

Usage: oxen moo [OPTIONS]

Options:
  -n, --number &lt;number&gt;  How long is the moo? [default: 2]
  -l, --loud             Make the MOO louder.
  -h, --help             Print help
</code></pre>
<p>Then you can simply run your command.</p>
<pre><code class="language-bash">./target/debug/oxen moo
</code></pre>
<p>You should see the output "moo"</p>
<pre><code>moo
</code></pre>
<p>You can also make the moo louder with the <code>--loud</code> flag and add more o's with the <code>-n</code> flag.</p>
<pre><code class="language-bash">$ ./target/debug/oxen moo --loud
MOO!
</code></pre>
<pre><code class="language-bash">$ ./target/debug/oxen moo -n 10
moooooooooo
</code></pre>
<p>üéâ And there you have it!</p>
<p>Congrats on adding your first command to Oxen! The moo command is already implemented in the main Oxen codebase as an easter egg and an example you can follow along with.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>We are all smart software engineers, but when it comes to entering a new codebase we all want confidence that making a change doesn't have a cascading effect. It is important to make sure that turning off the (proverbial) lights in the kitchen üí° doesn't make the roof collapse üè†.</p>
<p>Luckily each command within Oxen has a well defined interface, and each command can be tested independently.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Initialize Repo
let repo = command::init("./test_repo")?;
// Add File
command::add(&amp;repo, &amp;"hello.txt")?;
// Commit File
command::commit(&amp;repo, &amp;"add hello.txt")?;
<span class="boring">}</span></code></pre></pre>
<p>We chain these commands together into a sequence of integration and unit tests to make sure the end to end system works as expected.</p>
<h1 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h1>
<p>The best place to reference when looking at tests within Oxen are the <code>lib/src/command</code> modules themselves. You'll find some familiar names within the <code>command::</code> namespace.</p>
<p>For example:</p>
<ul>
<li><a href="https://github.com/Oxen-AI/Oxen/blob/main/src/lib/src/command/init.rs">command::init</a></li>
<li><a href="https://github.com/Oxen-AI/Oxen/blob/main/src/lib/src/command/add.rs">command::add</a></li>
<li><a href="https://github.com/Oxen-AI/Oxen/blob/main/src/lib/src/command/commit.rs">command::commit</a></li>
</ul>
<p>All tests for these commands are found below their respective module. Let's look at an example command and break down the different parts of the test.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    // ... include necessary modules

    #[test]
    fn test_command_init() -&gt; Result&lt;(), OxenError&gt; {
        test::run_empty_dir_test(|repo_dir| {
            // Init repo
            let repo = command::init(repo_dir)?;

            // Init should create the .oxen directory
            let hidden_dir = util::fs::oxen_hidden_dir(repo_dir);
            let config_file = util::fs::config_filepath(repo_dir);
            assert!(hidden_dir.exists());
            assert!(config_file.exists());

            Ok(())
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>First you will notice that the tests are within a <code>mod tests</code> block. This is a Rust feature that allows you to group tests together within a particular module.</p>
<p>In order to run all the tests within a particular command module you can run:</p>
<pre><code class="language-bash">cargo test --lib command::init
</code></pre>
<p>This will run all the tests within the <code>command::init</code> module.</p>
<h1 id="returning-errors"><a class="header" href="#returning-errors">Returning Errors</a></h1>
<p>You will notice that all the tests return <code>Result&lt;(), OxenError&gt;</code>. This means they will catch any errors that might occur when running different command.</p>
<p>The <code>OxenError</code> is a custom error type that is defined in the <a href="https://github.com/Oxen-AI/Oxen/blob/main/src/lib/src/error.rs">lib/src/error.rs</a> file. It is a simple enum that represents an error that can occur in Oxen. When you unwrap <code>?</code> a function that returns a <code>Result&lt;(), OxenError&gt;</code> you will receive the error and the test will fail.</p>
<h1 id="setup--teardown"><a class="header" href="#setup--teardown">Setup &amp; Teardown</a></h1>
<p>Next you will see that most tests are wrapped in a closure defined in our <a href="https://github.com/Oxen-AI/Oxen/blob/main/src/lib/src/test.rs">test.rs</a> file.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>test::run_empty_dir_test(|repo_dir| {
    // ... your test code here

    Ok(())
})
<span class="boring">}</span></code></pre></pre>
<p>These closures takes care of a lot of the boiler plate around setting up a test directory, and deleting it after the test is run.</p>
<p>For example <code>run_empty_dir_test</code> will pass a unique directory to the closure, and delete it when finished. This way we can run all the isolated tests in parallel and not worry about leaking files from one test impacting another.</p>
<p>There are many other helper functions you can use to setup and teardown your tests, including populating repositories with sample data, and setting up remote repositories. See the full list in the <a href="https://github.com/Oxen-AI/Oxen/blob/main/src/lib/src/test.rs">test.rs</a> file.</p>
<h1 id="running-all-tests"><a class="header" href="#running-all-tests">Running All Tests</a></h1>
<p>Make sure your server is running on the default port and host, then run</p>
<p><em>Note:</em> tests open up a lot of file handles, so limit num test threads if running everything.</p>
<p>You an also increase the number of open files your system allows ulimit before running tests:</p>
<pre><code>ulimit -n 10240
</code></pre>
<pre><code>cargo test -- --test-threads=$(nproc)
</code></pre>
<p>It can be faster (in terms of compilation and runtime) to run a specific test. To run a specific library test:</p>
<pre><code>cargo test --lib test_get_metadata_text_readme
</code></pre>
<p>To run with all debug output and run a specific test</p>
<pre><code>env RUST_LOG=debug,liboxen=debug,integration_test=debug cargo test -- --nocapture test_command_push_clone_pull_push
</code></pre>
<p>To set a different test host you can set the <code>OXEN_TEST_HOST</code> environment variable</p>
<pre><code>env OXEN_TEST_HOST=0.0.0.0:4000 cargo test
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-releasing-oxen-into-the-wild-"><a class="header" href="#-releasing-oxen-into-the-wild-">üêÇ Releasing Oxen Into The Wild üåæ</a></h1>
<p>Right now this is mainly for <a href="https://www.linkedin.com/in/greg-schoeninger/">me</a> to document how I release new versions of the open source Oxen.ai binaries.</p>
<p>If anyone wants to help with the release process, please let me know!</p>
<h2 id="bump-cliserver-versions"><a class="header" href="#bump-cliserver-versions">Bump CLI/Server Versions</a></h2>
<p>For the CLI and Oxen-Server binaries, make sure to update in all Cargo.toml files in our <a href="https://github.com/Oxen-AI/Oxen">Oxen-AI/Oxen</a> repo.</p>
<ul>
<li><a href="https://github.com/Oxen-AI/Oxen/blob/main/Cargo.toml">Cargo.toml</a></li>
<li><a href="https://github.com/Oxen-AI/Oxen/blob/main/src/server/Cargo.toml">src/server/Cargo.toml</a></li>
<li><a href="https://github.com/Oxen-AI/Oxen/blob/main/src/cli/Cargo.toml">src/cli/Cargo.toml</a></li>
</ul>
<h2 id="create-tag"><a class="header" href="#create-tag">Create Tag</a></h2>
<p>We use git tags to kick off CI within GitHub actions.</p>
<p><code>git tag -a v$VERSION -m "version $VERSION"</code></p>
<h2 id="push-tag"><a class="header" href="#push-tag">Push Tag</a></h2>
<p>Builds will show up in this repositories <a href="https://github.com/Oxen-AI/Oxen/releases">releases</a> with the tag you just specified.</p>
<p><code>git push origin v$VERSION</code></p>
<h2 id="update-homebrew-install"><a class="header" href="#update-homebrew-install">Update Homebrew Install</a></h2>
<p>There are separate homebrew repositories for the <code>oxen</code> CLI and the <code>oxen-server</code> binary.</p>
<p><a href="https://github.com/Oxen-AI/homebrew-oxen">Oxen-AI/homebrew-oxen</a></p>
<p><a href="https://github.com/Oxen-AI/homebrew-oxen-server">Oxen-AI/homebrew-oxen-server</a></p>
<p>You will need to compute shasum(s) of each release and update the <code>Formula/*.rb</code> in both repos above.</p>
<p>Use the <a href="https://github.com/Oxen-AI/homebrew-oxen/blob/main/compute_hashes.sh">compute_hashes.sh</a> script in <a href="https://github.com/Oxen-AI/homebrew-oxen">homebrew-oxen</a> repo to compute the shasum(s) of each release.</p>
<p>To verify the formula(s) locally:</p>
<pre><code>cd /path/to/homebrew-oxen-server
brew install Formula/oxen.rb
oxen --version
</code></pre>
<pre><code>cd /path/to/homebrew-oxen-server
brew install Formula/oxen-server.rb
oxen-server --version
</code></pre>
<h2 id="update-release-notes"><a class="header" href="#update-release-notes">Update Release Notes</a></h2>
<p>TODO: We need to get better at this.</p>
<p>Suggestions welcome üôè.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-objects"><a class="header" href="#domain-objects">Domain Objects</a></h1>
<p>Now for the fun part! Hopefully you have already <a href="./development/build_and_run.html">built Oxen</a> and learned how to <a href="./development/add_command.html">add your first command</a>.</p>
<p>In order to fully grok the Oxen codebase, it's important to define a few terms and understand the different <a href="domains.html">domain objects</a>. This way you'll have the right terminology to build upon and know where to look when adding or debugging features.</p>
<p>These domains are defined so we are all speaking the same language while diving into the code base. We will start with what the objects are, why they exist, and how objects are stored on disk, then we will build up intuition of how the system works as a whole.</p>
<h1 id="oxen-init"><a class="header" href="#oxen-init">oxen init</a></h1>
<p>Similar to <code>git</code>, we store all the meta data for a repository in a hidden local <code>.oxen</code> directory. To start the learning journey let's initialize and empty Oxen repository locally by using <a href="./commands/init.html">oxen init</a>.</p>
<pre><code class="language-bash">mkdir my-repo
cd my-repo
oxen init
</code></pre>
<p>The best way to start learning the architecture and different domain objects is by poking around in this directory.</p>
<pre><code class="language-bash">ls .oxen
</code></pre>
<p>You will see a variety of files and folders, including:</p>
<pre><code>commits/
history/
objects/
refs/
HEAD
config.toml
</code></pre>
<p>Let's use these files and folders as a jumping off point to learn about the different domain objects.</p>
<h1 id="first-up-repositories"><a class="header" href="#first-up-repositories">First Up: Repositories</a></h1>
<p>All of the domain objects exist within the context of a "Repository", so let's <a href="domains/repositories.html">start there</a>. All of the files and folders within the <code>.oxen</code> directory represent different sub components of a Repository, but we need some over arching objects to kick the process all off. These are what we call the <code>LocalRepository</code> and <code>RemoteRepository</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="repositories"><a class="header" href="#repositories">Repositories</a></h1>
<p>When we talk about data in Oxen, we usually talk about "Repositories". A Repository lives within your working directory of data in a hidden <code>.oxen</code> directory. You can think of a Repository as a series of snapshots of your data at any given point in time.</p>
<p><img src="domains//images/versions.png" alt="File Versions" /></p>
<p>Each snapshot contains a "mini filesystem" representing all the files and folders in that snapshot. The each mini filesystem is represented by a <a href="domains/domains/commits.html">commit</a>, and is stored in the <code>.oxen</code> directory so that we can return to it at any point in time.</p>
<p>To see this in action let's instantiate a local oxen repository and see what it looks like.</p>
<pre><code class="language-bash">$ oxen init
$ ls -trla
</code></pre>
<pre><code>total 0
drwxr-xr-x  23 bessie  staff  736 May 22 16:41 ../
drwxr-xr-x   3 bessie  staff   96 May 22 16:41 ./
drwxr-xr-x  10 bessie  staff  320 May 22 16:41 .oxen/
</code></pre>
<p>This magic <code>.oxen</code> directory is what will hold all the snapshots of your data. Think of it as a local database that lets you roll back your data to any point in time.</p>
<h1 id="content-addressable-file-system"><a class="header" href="#content-addressable-file-system">Content Addressable File System</a></h1>
<p>How are the different versions stored on disk? Let's add and commit some files to the repository and see what happens.</p>
<pre><code class="language-bash">$ echo "Hello" &gt; hello.txt
$ echo "World" &gt; world.txt
$ oxen add hello.txt world.txt
$ oxen commit -m "Add hello.txt and world.txt"
</code></pre>
<p>Each file that gets added and committed to oxen gets stored in a <a href="https://en.wikipedia.org/wiki/Content-addressable_storage">Content Addressable File System</a> in the <code>.oxen/versions</code> directory. Oxen first computes a <a href="domains/optimizations/hashing.html">hash of the file</a>, then stores the file in a sub directory that mirrors the hash. This means that the file can be retrieved by its hash at any time.</p>
<pre><code class="language-bash">$ tree .oxen/versions

.oxen/versions
‚îî‚îÄ‚îÄ files
    ‚îú‚îÄ‚îÄ 18
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 066113d946cfa640ffc8773c83f61b
    ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data.txt
    ‚îî‚îÄ‚îÄ a7
        ‚îî‚îÄ‚îÄ 666c8f5aaf946ca629d9d20c29aa6a
            ‚îî‚îÄ‚îÄ data.txt

6 directories, 2 files
</code></pre>
<p>What's up with these funky hexadecimal directory names? Well each directory is a <a href="domains/optimizations/hashing.html">xxHash</a> of the file. To see this in action, Oxen has a handy command to inspect information about an individual file.</p>
<pre><code class="language-bash">oxen info -v world.txt

hash	size	data_type	mime_type	extension	last_updated_commit_id
18066113d946cfa640ffc8773c83f61b	6	text	text/plain	txt	2c610ae8e424a4c8
</code></pre>
<p><code>oxen info</code> prints out a tab separated list of the hash, size, data type, mime type, extension, and the last updated commit id of the file.</p>
<p>In this case, the hash for the <code>world.txt</code> file is <code>18066113d946cfa640ffc8773c83f61b</code>. As for the directory structure above, you can see we split the hash and use the first two characters (<code>18</code>) of the hash as a prefix to the directory name. This is a common pattern in content addressable file systems to make sure you do not have too many sub-directories in a single directory.</p>
<h1 id="manually-inspect-older-versions"><a class="header" href="#manually-inspect-older-versions">Manually Inspect Older Versions</a></h1>
<p>Currently the files in Oxen are uncompressed in the versions directory, so you can simply <code>cat</code> the file to see the contents.</p>
<pre><code class="language-bash">$ cat .oxen/versions/files/a7/666c8f5aaf946ca629d9d20c29aa6a/data.txt

Hello
</code></pre>
<blockquote>
<p>Note: We have compression in our list of <a href="domains/improvements.html">future improvements</a> that could be made to the system, but the fact that we keep them uncompressed is a nice property of the system. It allows us to take advantage of the native file format of the files on disk with out additional compression / decompression steps.</p>
</blockquote>
<h2 id="storing-new-versions"><a class="header" href="#storing-new-versions">Storing New Versions</a></h2>
<p>Let's change the <code>hello.txt</code> file and commit it again.</p>
<pre><code class="language-bash">$ echo "Hello, World!" &gt; hello.txt
$ oxen add hello.txt
$ oxen commit -m "Update hello.txt"
</code></pre>
<p>Now look at the <code>.oxen/versions</code> directory. You will see that we have a new hashed directory for the file. This means that the file has been updated and a new snapshot has been created.</p>
<pre><code class="language-bash">$ tree .oxen/versions

.oxen/versions
‚îî‚îÄ‚îÄ files
    ‚îú‚îÄ‚îÄ 18
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 066113d946cfa640ffc8773c83f61b
    ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data.txt
    ‚îú‚îÄ‚îÄ a7
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 666c8f5aaf946ca629d9d20c29aa6a
    ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data.txt
    ‚îî‚îÄ‚îÄ ce
        ‚îî‚îÄ‚îÄ 1931b6136c7ad3e2a42fb0521986ba
            ‚îî‚îÄ‚îÄ data.txt

8 directories, 3 files
</code></pre>
<p>Let's look at each individual file in the versions dir.</p>
<pre><code class="language-bash">$ cat .oxen/versions/files/a7/666c8f5aaf946ca629d9d20c29aa6a/data.txt
Hello

$ cat .oxen/versions/files/18/066113d946cfa640ffc8773c83f61b/data.txt
World

$ cat .oxen/versions/files/ce/1931b6136c7ad3e2a42fb0521986ba/data.txt
Hello, World!
</code></pre>
<p>While this doesn't give you the full picture of how Oxen works, hopefully gives you a starting point into the Content Addressable File System that Oxen uses to store all versions of the files. We will get into the details of the <a href="domains/domains/commits.html">commit databases</a> and other data structures as we dive into more domains.</p>
<h2 id="localrepository"><a class="header" href="#localrepository">LocalRepository</a></h2>
<p>Since all of the data for all of the versions is simply stored in a hidden subdirectory, the first object we introduce is the <code>LocalRepository</code>. This object simply represents the <code>path</code> to the repository so that we know where to look for subsequent objects.</p>
<p><a href="https://github.com/Oxen-AI/Oxen/blob/main/src/lib/src/model/repository/local_repository.rs">src/lib/src/model/repository/local_repository.rs</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LocalRepository {
    pub path: PathBuf,
    // Optional remotes to sync the data to
    remote_name: Option&lt;String&gt;,
    pub remotes: Vec&lt;Remote&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Whenever starting down a code path within the CLI the first thing we do is find where the <code>.oxen</code> directory is and instantiate our <code>LocalRepository</code> object.</p>
<p>There is a handy helper method to get a repo from the current dir. This recursively traverses up in the directory structure to find a <code>.oxen</code> directory and instantiates the <code>LocalRepository</code> object.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let repository = LocalRepository::from_current_dir()?;
<span class="boring">}</span></code></pre></pre>
<p>You may want to reference the code for the <a href="https://github.com/Oxen-AI/Oxen/blob/main/src/cli/src/cmd/add.rs">add</a> command to see how instantiating a <code>LocalRepository</code> works in practice.</p>
<p>You will notice that not only does a <code>LocalRepository</code> have a <code>path</code>, but it also has a <code>remote_name</code> and <code>remotes</code>. These are read from <code>.oxen/config.toml</code> and tell inform Oxen where to sync the data to.</p>
<h1 id="remotes"><a class="header" href="#remotes">Remotes</a></h1>
<p>A remote in the context of Oxen is simply a name and a url. The name is a human readable representation and the url is the actual location of the remote repository.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Remote {
    pub name: String,
    pub url: String,
}
<span class="boring">}</span></code></pre></pre>
<p>The remotes can be set through the <code>oxen config</code> command.</p>
<pre><code class="language-bash">oxen config --set-remote origin http://localhost:3001/my-namespace/my-repo
</code></pre>
<p>If you look in the <code>.oxen/config.toml</code> file you will see the remotes listed there.</p>
<pre><code class="language-toml">remote_name = "origin"

[[remotes]]
name = "origin"
url = "http://localhost:3001/my-namespace/my-repo"
</code></pre>
<p>You can have multiple remotes as well as a default remote specified by <code>remote_name</code>. The default remote is the remote that will be used when you run <code>oxen push</code> or <code>oxen pull</code> without specifying a remote.</p>
<h2 id="remoterepository"><a class="header" href="#remoterepository">RemoteRepository</a></h2>
<p>On the other end of the <code>LocalRepository</code> is the <code>RemoteRepository</code>. This object represents the remote repository that the <code>LocalRepository</code> is connected to. It has the same <code>url</code> as the <code>Remote</code> object.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RemoteRepository {
    pub namespace: String,
    pub name: String,
    pub remote: Remote,
}
<span class="boring">}</span></code></pre></pre>
<p>All repositories that are stored on the <code>oxen-server</code> have a <code>namespace</code> and <code>name</code>. This helps us organize the repositories on disk, as well as in a way that is meaningful to the user.</p>
<p>In order to create a <code>RemoteRepository</code> we will first need to spin up an <code>oxen-server</code> instance. From your debug build you can do something like the following.</p>
<pre><code class="language-bash">export SYNC_DIR=/path/to/sync/dir
./target/debug/oxen-server start
</code></pre>
<p>This will start a server on the default host 0.0.0.0 and port 3000. The environment variable <code>SYNC_DIR</code> tells the server where to write the data to on disk.</p>
<p>Then we can use the <code>oxen create-remote</code> command from the CLI.</p>
<pre><code class="language-bash">oxen create-remote --name my-namespace/my-repo --host 0.0.0.0:3000 --scheme http
</code></pre>
<p>If you look in the <code>SYNC_DIR</code> you will see a directory structure that mirrors the namespace/repo-name of the repository you just created. There will be a <code>.oxen</code> directory with the remote repository created for you as well.</p>
<pre><code class="language-bash">ls -trla /path/to/sync/dir/my-namespace/my-repo/.oxen
</code></pre>
<p>What's cool is that on disk the <code>RemoteRepository</code> is the same structure as the <code>LocalRepository</code>. This means that we can use the same code to manipulate the <code>RemoteRepository</code> on the server as we can the <code>LocalRepository</code> on the client.</p>
<p>If you didn't configure the remote earlier, you can do so now.</p>
<pre><code class="language-bash">oxen config --set-remote origin http://0.0.0.0:3000/my-namespace/my-repo
</code></pre>
<p>Then simply push the data to the remote.</p>
<pre><code class="language-bash">oxen push
</code></pre>
<p>This copies all the data from the local .oxen directory to the remote repository. Remember the versions directory from before? Let's see what it looks like on the remote.</p>
<pre><code class="language-bash">$ cat /path/to/sync/dir/my-namespace/my-repo/.oxen/versions/files/ce/1931b6136c7ad3e2a42fb0521986ba/data.txt
Hello, World!
</code></pre>
<p>There we go! Data is in tact on the remote server. This is the beauty of Oxen. There are not too many fancy bells and whistles when you look under the hood. Just a content addressable file system with a library that is shared between the client and server.</p>
<p>Next up we will look at <a href="domains/domains/commits.html">Commits</a>. These objects represent the group of files that were are in a single snapshot, and we will learn how Oxen knows which versions were added, removed, changed in the repository and when.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commits"><a class="header" href="#commits">Commits</a></h1>
<p>If you are familiar with <code>git</code> the concept of a <code>commit</code> and <code>branch</code> should be very familiar. What you may not have done is look under the hood as to how they are stored. In Oxen, many of the concepts are similar.</p>
<p>A commit is a checksum or <a href="domains/optimizations/hashing.html">hash value</a> representing all the files is within a specific version. You may recognize them as a string of hexadecimal characters  (0‚Äì9 and a‚Äìf) looking something like <code>4b27c4b16fb736a4</code>.</p>
<p>Run <code>oxen log</code> within your Oxen repository and you will see the initial commit.</p>
<pre><code>commit 4b27c4b16fb736a4

Author: ox
Date:   Thursday, 09 May 2024 22:29:00 +00

    Initialized Repo üêÇ
</code></pre>
<p>You will see these hashes all over the place in Oxen and can use them as pointers to get to specific versions.</p>
<h1 id="commits-database"><a class="header" href="#commits-database">Commits Database</a></h1>
<p>In order to understand the Commit object better, let's look at how it is stored on disk. Again we are going to peek in the <code>.oxen</code> directory as our starting point. Specifically at the <code>commits</code> directory.</p>
<pre><code>$ ls .oxen/commits

000008.sst       000014.log       IDENTITY         LOG              OPTIONS-000012
000013.sst       CURRENT          LOCK             MANIFEST-000015  OPTIONS-000017
</code></pre>
<p>This entire directory is the commits database. Under the hood Oxen stores most of it's data with <a href="https://rocksdb.org/">RocksDB</a>. This is a fast key-value store that makes it fast to insert and read data without loading the entire database into memory. Specifically we use the rust bindings for RocksDB found in <a href="https://docs.rs/rocksdb/latest/rocksdb/">this repository</a>.</p>
<p>These files are hard to inspect on their own, so we can use the <code>oxen db</code> command to inspect the commits database. The <code>oxen db list</code> command will print out all the commits in the database.</p>
<pre><code>$ oxen db list .oxen/commits
</code></pre>
<p>You'll see this prints the entire key value store as tab separated values.</p>
<pre><code>2c610ae8e424a4c8	{"id":"2c610ae8e424a4c8","parent_ids":["440b54a690b44fd7"],"message":"Add hello.txt and world.txt","author":"oxbot","email":"oxbot@oxen.ai","root_hash":"cf2c5e5f057b589230654260d07fa7c3","timestamp":"2024-05-23T00:40:20.555747Z"}
440b54a690b44fd7	{"id":"440b54a690b44fd7","parent_ids":[],"message":"Initialized Repo üêÇ","author":"oxbot","email":"oxbot@oxen.ai","root_hash":"99aa06d3014798d86001c324468d497f","timestamp":"2024-05-23T00:40:02.047406Z"}
a36e6239a1ab49d4	{"id":"a36e6239a1ab49d4","parent_ids":["2c610ae8e424a4c8"],"message":"Update hello.txt","author":"oxbot","email":"oxbot@oxen.ai","root_hash":"7121f5302a90ea338f129ca169a39739","timestamp":"2024-05-23T00:43:53.303893Z"}
</code></pre>
<p>If you want to get a specific commit, you can use the <code>oxen db get</code> command. For example, to get the commit <code>2c610ae8e424a4c8</code>, you can run the following command.</p>
<pre><code>$ oxen db get .oxen/commits/ 2c610ae8e424a4c8 | jq
</code></pre>
<pre><code>{
  "id": "2c610ae8e424a4c8",
  "parent_ids": [
    "440b54a690b44fd7"
  ],
  "message": "Add hello.txt and world.txt",
  "author": "oxbot",
  "email": "oxbot@oxen.ai",
  "timestamp": "2024-05-23T00:40:20.555747Z"
}
</code></pre>
<p>Ah, there is a nice beautiful commit object. You can see that the raw values are simply stored in the db as json. There is a list of parent commit ids, a message, the author, the email, and the timestamp.</p>
<h1 id="commit-metadata"><a class="header" href="#commit-metadata">Commit Metadata</a></h1>
<p>All of the metadata within a commit object is important for computing it's <code>id</code>. The id can be used to verify the integrity of the data within a commit. More on this later.</p>
<p>The first piece of metadata is the user that made the commit. The user data is read from the global <code>~/.config/oxen/user_config.toml</code> file. You can set your user info with the <code>oxen config</code> command.</p>
<pre><code class="language-bash">$ oxen config --name 'Bessie' --email 'bessie@your_email.com'
</code></pre>
<pre><code class="language-bash">$ cat ~/.config/oxen/user_config.toml
</code></pre>
<pre><code>name = "Bessie"
email = "bessie@your_email.com"
</code></pre>
<p>It also contains the timestamp of the commit, and a user provided message. All of these pieces of data are used in computing the commit id, which is a unique representation of the data in this commit.</p>
<h1 id="commit-id-hash"><a class="header" href="#commit-id-hash">Commit Id (Hash)</a></h1>
<p>Each commit has a unique id (hash) that can be verified to ensure the integrity of the data in this commit. It is a combination of the data within all the files of the commit, the user data, timestamp, and the message.</p>
<p>What's nice about this is that once the data has been synced to the remote server, we can verify that the data is valid by computing the hashes of the files and the commit data and comparing this to the id of the commit in the database.</p>
<h1 id="commit-history"><a class="header" href="#commit-history">Commit History</a></h1>
<p>Every commit (except the first) has a list of parent commit ids. Most commits have a single parent, but in the case of a merge commit, there can be multiple parent commit ids. You can traverse the commit history by following the parent commit ids until you hit the first commit.</p>
<p>You can use the <code>oxen log</code> command to print out the commit history starting with the most recent commit on the current branch.</p>
<h2 id="next-up-branches"><a class="header" href="#next-up-branches">Next Up: Branches</a></h2>
<p>Learn how commits relate to <a href="domains/./branches.html">Branches</a> in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="branches"><a class="header" href="#branches">Branches</a></h1>
<p>Branches are a key feature of many VCS systems. They allow users to work in parallel without making changes that step on each other's toes.</p>
<p>The branching model in Oxen is inspired by <code>git</code> meaning branches are lightweight and quick to create. When creating a branch, we are never copying any of the raw datasets in the repository. Under the hood, a branch is really just a named reference to a commit. Creating a new branch simply creates a new named reference.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Branch {
    pub name: String,
    pub commit_id: String,
}
<span class="boring">}</span></code></pre></pre>
<p>When a repository is first initialized with <code>oxen init</code>, a single commit is made and a branch is created called <code>main</code> that points to it.</p>
<h1 id="refs"><a class="header" href="#refs">Refs</a></h1>
<p>To see how this works in practice, let's look at how branches are stored on disk. All of the branches within a repository are stored in a key-value rocksdb database. This database can be found in the <code>.oxen/refs</code> directory.</p>
<p>Let's inspect this database with our <code>oxen db list</code> command.</p>
<pre><code class="language-bash">$ oxen db list .oxen/refs

main	c719c887cc250784
</code></pre>
<p>This shows us that there is a single branch, <code>main</code>, that points to the commit id <code>c719c887cc250784</code>.</p>
<p>If we create a new branch, say <code>foo</code>, it will also be stored in the database with the same commit id as the current branch you are on.</p>
<pre><code class="language-bash">$ oxen checkout -b foo
$ oxen db list .oxen/refs

main	c719c887cc250784
foo	c719c887cc250784
</code></pre>
<p>To see the list of current branches as well as which one you currently have checked out, you can use the <code>oxen branch</code> command.</p>
<pre><code class="language-bash">$ oxen branch

* foo
  main
</code></pre>
<p>The <code>*</code> indicates the <code>foo</code> branch is currently checked out. The way we store the current branch is by creating a <code>HEAD</code> file in the <code>.oxen</code> directory.</p>
<p>This file contains the name of the branch or commit id that is currently checked out.</p>
<pre><code class="language-bash">$ cat .oxen/HEAD

foo
</code></pre>
<p>Let's make a commit and see how the branches stored on disk change.</p>
<pre><code class="language-bash">$ echo "foo" &gt; foo.txt
$ oxen add foo.txt
$ oxen commit -m "foo commit"

Committing with message: foo commit
Commit 9ef4176b1b4422a7 done.
</code></pre>
<p>We now have a new commit id <code>9ef4176b1b4422a7</code>. If we look at the <code>refs</code> database, we can see that the <code>foo</code> branch has been updated to point to the new commit id.</p>
<pre><code class="language-bash">$ oxen db list .oxen/refs

foo	9ef4176b1b4422a7
main	c719c887cc250784
</code></pre>
<p>If we look at <code>oxen log</code> we will see that the <code>foo</code> branch is now the most recent commit.</p>
<pre><code class="language-bash">commit 9ef4176b1b4422a7

Author: Ox Bot
Date:   Thursday, 30 May 2024 04:04:53 +00

    foo commit

commit c719c887cc250784

Author: Ox Bot
Date:   Tuesday, 28 May 2024 03:03:49 +00

    adding questions.jsonl
</code></pre>
<p>You can checkout a specific commit by using the <code>oxen checkout</code> command with the commit id.</p>
<pre><code class="language-bash">$ oxen checkout c719c887cc250784
</code></pre>
<p>This will update the <code>HEAD</code> file to point to the commit id instead of the branch name.</p>
<pre><code class="language-bash">$ cat .oxen/HEAD

c719c887cc250784
</code></pre>
<p>You will notice that our <code>foo.txt</code> file is no longer present in the working directory. If you perform a <code>oxen status</code> you will see that we are now in a "detached HEAD" state. This means that we are no longer on a branch and are instead on an individual commit.</p>
<p>Don't worry, the file <code>foo.txt</code> is still alive and well in the <code>.oxen/versions</code> directory, and can be restored by checking out the <code>foo</code> branch again.</p>
<pre><code class="language-bash">$ oxen checkout foo
</code></pre>
<p>That's it! The relationship between branches, commits, and the HEAD commit is really that simple. Branches are just a named reference to a commit id that make it easier to find a particular chain of commits.</p>
<p>You can progress a branch as many commits as you want without affecting the main branch. When you are ready to merge your branch into the main branch, you can use the <code>oxen merge</code> command which will be covered later.</p>
<h1 id="next-up-files--directories"><a class="header" href="#next-up-files--directories">Next Up: Files &amp; Directories</a></h1>
<p>Now that you know the basic data structures for branches and commits, let's dive into how branches and commits are tied to a set of files and directories.</p>
<p>Next Up: <a href="domains//domains/objects.html">Files &amp; Directories</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="files-directories-and-merkle-trees-"><a class="header" href="#files-directories-and-merkle-trees-">Files, Directories and Merkle Trees üå≤</a></h1>
<p>When you create a commit within Oxen, you can think of it as a snapshot of the state of the files and directories in the repository at a particular point in time. This means each commit will need a reference to all the files and directories that are present in the repository at the time of the commit.</p>
<p>Let's use a small dataset as an example.</p>
<pre><code>README.md
LICENSE
images/
  image0.jpg
  image1.jpg
  image2.jpg
  image3.jpg
  image4.jpg
</code></pre>
<p>This is a simple file structure with a README.md at the top level and a sub-directory of images. Start by initializing a new repository, then adding and committing the files.</p>
<pre><code class="language-bash">oxen init
oxen add README.md
oxen add images/
oxen commit -m "adding data"
</code></pre>
<p>On commit we save off all the hashes of the file contents and save the data into a Content Addressable File System (CAFS) within the <code>.oxen/versions</code> directory. This makes it so we don't duplicate the same file data across commits.</p>
<pre><code class="language-bash">$ tree .oxen/versions/files/

.oxen/versions/files/
‚îú‚îÄ‚îÄ 43
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 94f02b679bcf0114b1fb631c250d0a
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data.jpg
‚îú‚îÄ‚îÄ 58
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 8b7f5296c1a6041d350d1f6be41b3
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data.jpg
‚îú‚îÄ‚îÄ 64
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ e1a1512c6d5b1b6dcf2122326370f1
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data.md
‚îú‚îÄ‚îÄ 74
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ bfd17b6b7c9b183878a26e1e62a30e
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data.jpg
‚îú‚îÄ‚îÄ 7c
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 42afd26e73b8bfbc798288f1def1ed
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data
‚îú‚îÄ‚îÄ c8
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ 2d11a1e1223598d930454eecfab6ea
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ data.jpg
‚îî‚îÄ‚îÄ dc
    ‚îî‚îÄ‚îÄ 92962a4b05f5453718783fe3fc4b10
        ‚îî‚îÄ‚îÄ data.jpg

15 directories, 7 files
</code></pre>
<p>Each file is accessible by its hash and original extension the file was stored with. For example, the hash of <code>images/image0.jpg</code> is <code>74bfd17b6b7c9b183878a26e1e62a30e</code> and it's extension is <code>jpg</code>, so the original contents can be found at <code>.oxen/versions/files/74/bfd17b6b7c9b183878a26e1e62a30e/data.jpg</code>.</p>
<p>To find the hash and extension of any file in a commit, you can use the <code>oxen info</code> command.</p>
<pre><code>oxen info images/image0.jpg
74bfd17b6b7c9b183878a26e1e62a30e	13030	image	image/jpeg	jpg	12099a4ca3b15c36
</code></pre>
<p>The CAFS makes it easy to fetch the file data for a given commit, but we need some sort of database that lists the original file names and paths. This way when switching between commits we can efficiently restore the files that have been added/changed/removed.</p>
<h1 id="naive-implementation"><a class="header" href="#naive-implementation">Naive Implementation</a></h1>
<p>The simplest solution would be to have a key-value database for every commit that listed the file paths and pointed to their hashes and extensions.</p>
<p>Commit A</p>
<pre><code>README.md -&gt; {"hash": "64e1a1512c6d5b1b6dcf2122326370f1", "extension": ".md"}
LICENSE -&gt; {"hash": "7c42afd26e73b8bfbc798288f1def1ed", "extension": ""}
images/image1.jpg -&gt; {"hash": "74bfd17b6b7c9b183878a26e1e62a30e", "extension": ".jpg"}
images/image2.jpg -&gt; {"hash": "dc92962a4b05f5453718783fe3fc4b10", "extension": ".jpg"}
images/image3.jpg -&gt; {"hash": "588b7f5296c1a6041d350d1f6be41b3", "extension": ".jpg"}
images/image4.jpg -&gt; {"hash": "c82d11a1e1223598d930454eecfab6ea", "extension": ".jpg"}
images/image5.jpg -&gt; {"hash": "4394f02b679bcf0114b1fb631c250d0a", "extension": ".jpg"}
</code></pre>
<p>We could store this in a rocksdb database in <code>.oxen/history/{commit_hash}/files</code>. The keys would be the file paths and the values would be the hashes and extensions. Then when swapping between commits all we would have to do is clear the current working directory and re-construct all the files from the respective commit database!</p>
<p>Psuedo Code:</p>
<pre><code class="language-bash">set commit_hash 1d278f841510b8e7
rm -rf working_dir
for dir, hash, ext in (oxen db list .oxen/versions/files/$commit_hash/) ; 
  mkdir -p working_dir/$dir ;
  cp .oxen/versions/files/$commit_hash/$hash/data$ext working_dir/$dir/ ;
end
</code></pre>
<p>Version control complete. Let's call it a day and go relax on the beach üòé üèùÔ∏è.</p>
<p>Of course, we are not here to build naive inefficient version control tool. Oxen is a blazing fast version control system that is designed to handle large amounts of data efficiently. Even if clearing and restoring the working directory is simple, there are many reasons it is not optimal (including wiping out untracked files üò±).</p>
<h2 id="how-do-we-make-it-faster"><a class="header" href="#how-do-we-make-it-faster">How do we make it faster?</a></h2>
<p>To see why this naive approach is sub-optimal, imagine we are collecting image training data for a computer vision system. We put Oxen in a loop adding one new image at a time to the <code>images/</code> directory. Each time we add an image we commit the changes.</p>
<pre><code class="language-fish">for i in (seq 100) ; 
  # imaginary data collection pipeline
  cp /path/to/images/image$i.jpg images/image$i.jpg ;

  # oxen add and commit
  oxen add images/image$i.jpg ;
  oxen commit -m "adding image$i" ;
end
</code></pre>
<p>If we had gone the naive route, this would balloon in redundancy even with just our list of pointers to hashes. Each database list repeats the same file paths and the hashes over and over again.</p>
<p>Commit A</p>
<pre><code>README.md         -&gt; hash1
LICENSE           -&gt; hash2
images/image0.jpg -&gt; hash3
images/image1.jpg -&gt; hash4
images/image2.jpg -&gt; hash5
images/image3.jpg -&gt; hash6
</code></pre>
<p>Commit B</p>
<pre><code>README.md         -&gt; hash1 # repeated
LICENSE           -&gt; hash2 # repeated
images/image0.jpg -&gt; hash3 # repeated
images/image1.jpg -&gt; hash4 # repeated
images/image2.jpg -&gt; hash5 # repeated
images/image3.jpg -&gt; hash6 # repeated
images/image4.jpg -&gt; hash7 # NEW
</code></pre>
<p>Commit C</p>
<pre><code>README.md         -&gt; hash1 # repeated
LICENSE           -&gt; hash2 # repeated
images/image0.jpg -&gt; hash3 # repeated
images/image1.jpg -&gt; hash4 # repeated
images/image2.jpg -&gt; hash5 # repeated
images/image3.jpg -&gt; hash6 # repeated
images/image4.jpg -&gt; hash7 # repeated
images/image5.jpg -&gt; hash8 # NEW
</code></pre>
<p>...</p>
<p>Commit 10_000</p>
<pre><code>README.md              -&gt; hash1
LICENSE                -&gt; hash2
images/image0.jpg      -&gt; hash3
images/image1.jpg      -&gt; hash4
images/image2.jpg      -&gt; hash5
images/image3.jpg      -&gt; hash6
images/image4.jpg      -&gt; hash7
images/image5.jpg      -&gt; hash8
...
images/image10_000.jpg -&gt; hash10_000
</code></pre>
<p>Do the math once we get to a dataset of 10,000 images. Each commit duplicates 10,000+1 values. 10,000 + 10,001 + 10,002 + 10,003 = 40,006 values in our collective databases.</p>
<pre><code>.oxen/history/COMMIT_A/files -&gt; 10,000 values
.oxen/history/COMMIT_B/files -&gt; 10,001 values
.oxen/history/COMMIT_C/files -&gt; 10,002 values
.oxen/history/COMMIT_D/files -&gt; 10,003 values

Total Values: 40,006
</code></pre>
<p>A key observation is that we are duplicating a lot of data across commits. This will be a common pattern to look for when optimizing the storage within Oxen.</p>
<h1 id="optimizations-w-merkle-trees"><a class="header" href="#optimizations-w-merkle-trees">Optimizations w/ Merkle Trees</a></h1>
<p>Adding one file should not require to you copy the entire key-value database. We need some sort of data structure that can efficiently store the file paths and hashes without duplicating too much data across commits.</p>
<p>Enter <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Trees</a> üå≤.</p>
<p>Files and directories are already organized in a tree like fashion, so a Merkle Tree is a more natural fit for storing and traversing the file structure to begin with. The Oxen Merkle Tree implementation also make it so when we add additional data, we only need to copy subtrees instead of copying the entire database for each commit.</p>
<p>What does a Merkle Tree within Oxen look like?</p>
<p><img src="domains//images/merkle_tree/commit_a.png" alt="Commit A" /></p>
<p>At the root node of the Merkle tree is a commit hash. This is the identifier you know and love which you can reference any commit in the system by.</p>
<p>The root commit hash represents the content of all the data below it, including the files contained in the <code>images/</code> directory as well as the files directly in the <code>.</code> root directory (README.md, LICENSE, etc). Additionally all the files within a directory get sectioned off into VNodes. We will return to the importance of VNodes in a bit.</p>
<p>At each level of the tree we see the contents of all the files hashed within that directory, and bucketed into VNodes.</p>
<h2 id="adding-a-file"><a class="header" href="#adding-a-file">Adding a File</a></h2>
<p>To see what happens when we add a new file to our repository, let's revisit our previous example of adding images to the <code>images/</code> directory. Say we have 8 images in our <code>images/</code> directory and we want to add a new image (9.jpg).</p>
<p>The first thing we have to do is find which VNode bucket it falls into (more on this later). Then we can recompute the hash of this subtree, and recursively update the hashes above it until we get to the root node.</p>
<p>In this case we make four total updates to the tree, highlighted in green.</p>
<ol>
<li>Add the contents of the new image to our <code>.oxen/versions/</code> directory</li>
<li>Find the VNode it belongs to, and deep copy it to a new VNode with a new hash</li>
<li>Update the VNode hash of the <code>images/</code> parent directory</li>
<li>Update the root node hash</li>
</ol>
<p><img src="domains//images/merkle_tree/commit_b.png" alt="Commit B" /></p>
<p>The Merkle Tree nodes are all global to the repository, and can get re-used and shared between commits. Instead of copying the entire database to our new commit, only copy the subtrees that changed. On adding a file, we only need to update a single VNode and copy it's contents. This is a much faster operation than copying every file within our databases.</p>
<p>For another example, let's see what happens when we update the <code>README.md</code> file.</p>
<p><img src="domains//images/merkle_tree/commit_c.png" alt="Commit C" /></p>
<p>This time, we only need to update the VNode that contains the <code>README.md</code> file and it's parent in the root node.</p>
<h2 id="what-is-this-vnode"><a class="header" href="#what-is-this-vnode">What is this "VNode"?</a></h2>
<p>One of the goals of Oxen is to be able to scale to directories with an arbitrary number of files. Imagine for a second that you have a directory of 100k or 1 million images. Storing all of these values directly at the directory level node would be inefficient. Every time you commit a single image to the directory, you would need to copy all the pointers and recompute the hash for the entire directory.</p>
<p>For example imagine we had no VNodes at the directory level.</p>
<p><img src="domains//images/merkle_tree/no_vnode.png" alt="No VNode" /></p>
<p>If we want to add a single file, we would have to copy all the pointers and recompute the hash for the entire directory.</p>
<p><img src="domains//images/merkle_tree/no_vnode_add_file.png" alt="Add File" /></p>
<p>VNode's add an intermediate bucket we can add files to so that we only have to copy a subset of pointers. Which VNode a file belongs to is computed from the hash of file path name itself. This way files get evenly distributed into buckets within the tree.</p>
<p><img src="domains//images/merkle_tree/images_w_vnode.png" alt="With VNode" /></p>
<p>You'll notice two parts to the VNode. The first is first two letters (<code>AB</code>) of the hash of the file path name, and the second is the hash of the VNode contents (<code>#DFEGA72</code>). To add an image, now we only need to find the bucket (based on it's file path), compute it's new hash, and make a copy of the items of the VNode database for it's new hash.</p>
<p><img src="domains//images/merkle_tree/images_w_vnode_add_file.png" alt="With VNode Add File" /></p>
<p>To drive this home, let's go back to our example directory with 10,000 images with the naive implementation from before. Remember 4 additions to the images directory after it contained 10,000 node resulted in 40,006 values in our database. Say our bucket size for VNodes is 10,000/256 ~= 40. This means on average we are copying 40 values with each commit. This will result in 10,160 total values in our DB instead of 40,006.</p>
<h2 id="file-chunk-deduplication"><a class="header" href="#file-chunk-deduplication">File Chunk Deduplication</a></h2>
<p>While the Merkle Tree optimizations we've talked about so far make adding and committing snapshots of the directory structure to Oxen snappy, there are even more optimizations we can do at the file level itself.</p>
<p>Sometimes Oxen üêÇ can get a little chunky and need to slim down üò≥.</p>
<p>Remember, so far each time you make a commit, we make an <em>entire copy</em> of the file contents itself and put it into the <code>.oxen/versions</code> directory under it's hash. Imagine you are editing and committing a CSV file one row at a time, and making a commit with each change. This results in a lot of duplicated data. We not only want Oxen to be efficient at storing many files, but also efficient at storing large files such as data frames of parquet, jsonl, csv, etc.</p>
<p>TODO: Image</p>
<p>To combat this, Oxen uses a technique called file chunk deduplication. Instead of storing the entire file in the <code>.oxen/versions</code> directory, if Oxen detects that a file is being modified over and over again, it chunks up the file into "chunks" and stores these chunks in the <code>.oxen/chunks</code> directory and then stores a reference to the chunks in the Merkle Tree.</p>
<p>TODO: Example of disk usage with and w/o file chunk dedup</p>
<h2 id="benefits-of-the-merkle-tree"><a class="header" href="#benefits-of-the-merkle-tree">Benefits of the Merkle Tree</a></h2>
<p>To summarize, there are a few nice properties of a Merkle Tree as our data structure.</p>
<ol>
<li>
<p>When we add, remove or change a file, we only need to update the subtree that contains that file. This means the storage grows logarithmically with the number of files in the repository instead of linearly.</p>
</li>
<li>
<p>To recompute the root hash of a commit, we only need to hash the file paths and the hashes of the files that have changed. This means we can efficiently verify the integrity of the data by recomputing subtrees.</p>
</li>
<li>
<p>We can use it to understand the small diff of the data that needs to be transferred over the network when syncing repositories.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>The core commands in commands in Oxen map to git so that it is an easy learning curve to get started.</p>
<pre><code class="language-bash">oxen init
oxen add images/
oxen status
oxen commit -m "adding images"
oxen push origin main
</code></pre>
<p>Join us as we break down each command step by step, as if you were building it from scratch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="init"><a class="header" href="#init">init</a></h1>
<p><code>oxen init</code></p>
<p>TODO: add details on how the command works</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="clone"><a class="header" href="#clone">clone</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>There are core data types that Oxen detects and can do special processing with. This helps increase visibility into your data, and makes it extensible to your use case.</p>
<ul>
<li>Text</li>
<li>Image</li>
<li>Audio</li>
<li>Video</li>
<li>Tabular</li>
<li>Blob</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h1>
<p>There are many optimizations that make Oxen go brrr. From the core merkle tree structure, to hashing protocol, to networking, to interacting with remote datasets. Oxen is meant to make it feel like you have terabytes of data at your fingertips whatever machine you are on.</p>
<h1 id="tldrs"><a class="header" href="#tldrs"><del>TLDRs</del></a></h1>
<p>We often get asked: "What makes Oxen different from other VCS?"</p>
<p>Without diving into the gnitty gritty details, here are some highlights. If you want to go deeper, don't worry, we also dive deep into the implementation details of each throughout the book.</p>
<h2 id="merkle-tree"><a class="header" href="#merkle-tree">Merkle Tree</a></h2>
<ul>
<li>Downloading Sub Trees</li>
<li>Per Folder Sub Trees</li>
<li>Block Level Dedup</li>
<li>Only download latest
<ul>
<li>When you get to TB scale data, you do not want to have to pull down data from previous commits to compute the current tree.</li>
</ul>
</li>
<li>Push / Pull Bottle Neck</li>
<li>Objects
<ul>
<li>Trees</li>
<li>VNodes</li>
<li>Blobs</li>
<li>Schemas</li>
</ul>
</li>
</ul>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<ul>
<li>xxHash</li>
<li>pure hashing throughput</li>
<li>non-cryptographic hashing fn</li>
</ul>
<h2 id="data-frames-and-schemas-are-first-class-citizens"><a class="header" href="#data-frames-and-schemas-are-first-class-citizens">Data Frames and Schemas are First Class Citizens</a></h2>
<p>Other VCS systems are optimized for text files and code. In the case of datasets, we often deal with data frames which have other properties such as schema that we want to track.</p>
<h2 id="native-file-formats"><a class="header" href="#native-file-formats">Native File Formats</a></h2>
<p>Take advantage of existing file formats such as arrow, parquet, duckdb, etc. Unlike git or other VCS that try to be smart with compression, we can leverage the existing file formats that are already highly optimized for the specific use case.</p>
<p>For example, apache arrow is a memory mapped file that makes random access to rows very fast. If we were to compress this data and reconstruct it we would lose the benefits of the memory mapped file.</p>
<p>This is a design tradeoff that is made throughout oxen which makes it less efficient in terms of storage on disk, but easier to integrate with.</p>
<p>Visibility into data is a key design goal of Oxen. Visibility means speed for data to be visible as well, and the less assumptions we make here, the more we can leverage and extend existing file formats.</p>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<ul>
<li>Fearless concurrency</li>
<li>Hashing data</li>
<li>Moooooving data over the network</li>
<li>Moooooving data on disk</li>
</ul>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<ul>
<li>Smart Chunking</li>
</ul>
<h2 id="remote-workspaces"><a class="header" href="#remote-workspaces">Remote Workspaces</a></h2>
<p>Don't download the entire dataset just to contribute.</p>
<ul>
<li>oxen remote add</li>
<li>oxen remote commit</li>
<li>oxen remote df</li>
<li>oxen remote ls</li>
</ul>
<h2 id="compression-coming-soon"><a class="header" href="#compression-coming-soon">Compression (Coming Soon)</a></h2>
<ul>
<li>Block level dedup</li>
<li>zlib</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merkle-tree-1"><a class="header" href="#merkle-tree-1">Merkle Tree</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="hashing-1"><a class="header" href="#hashing-1">Hashing</a></h1>
<p>One of the optimizations within Oxen is to use the <a href="https://github.com/Cyan4973/xxHash">xxHash algorithm</a> to hash the file contents. This is a very fast hashing algorithm that is designed to be very memory efficient. It is also very fast to compute.</p>
<p>Compared to SHA or MD5 hashes which can hash data at &lt; 1GB/s, xxHash can hash data at 30GB/s. This is a significant improvement for large files, and speeds up the process of adding and committing files to Oxen.</p>
<h1 id="inspect-file-hashes"><a class="header" href="#inspect-file-hashes">Inspect File Hashes</a></h1>
<p>You can quickly inspect the xxHash of any file using the <code>oxen info</code> command.</p>
<p><code>oxen info -v file.txt</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compression"><a class="header" href="#compression">Compression</a></h1>
<p>TODO: Block level deduplication can be turned on in order to shrink older datasets. It comes at a reconstruction cost of the data, so can be turned on and off depending on your use case.</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="storage"><a class="header" href="#storage">Storage</a></h1>
<p>TODO: Support different storage backends</p>
<ul>
<li>Local SSDs</li>
<li>NFS</li>
<li>S3</li>
<li>FSpec</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-not-write-an-extension-for-git"><a class="header" href="#why-not-write-an-extension-for-git">Why not write an extension for Git?</a></h1>
<p>We often get asked "Why not use Git-LFS?" and why write an entire Version Control System (VCS) from scratch?</p>
<p>The short answer is developer experience. Owning the tool means owning the end to end developer experience. The plugins and extensions to git that we have tried in the path feel like they were shoe horned in and clunky.</p>
<p>There are certain properties of git that make it great for versioning code, but fall short when it comes to data. Git is really good at huge histories of small text files, like code bases. Where git does not shine is binary files. Many datasets consist of binary files such as images, video, audio, parquet files, etc which are not efficiently stored in git.</p>
<p>There are extensions to git such as git-LFS that work okay when you have one or two large assets that are complimentary to your code, but they are still extremely slow when it comes to versioning large sets of large binary files.</p>
<p>This section dives into some of the reasons why we did not want to use Git-LFS and wrote an entire VCS from scratch.</p>
<h1 id="lfs-is-more-complexity"><a class="header" href="#lfs-is-more-complexity">LFS is More Complexity</a></h1>
<p>The first reason is purely the mental model users have to keep in their head.</p>
<p>To quote <a href="https://gregoryszorc.com/blog/2021/05/12/why-you-shouldn%27t-use-git-lfs/">Gregory Szorc</a>:</p>
<p><em>"LFS is more complex for Git end users.</em></p>
<p><em>Git users have to install, configure, and sometimes know about the existence of Git LFS. Version control should just work. Large file handling should just work. End-users shouldn't have to care that large files are handled slightly differently from small files."</em></p>
<h1 id="network-protocols"><a class="header" href="#network-protocols">Network Protocols</a></h1>
<p>Git sequentially reads and writes objects via <a href="https://dev.to/calebsander/git-internals-part-3-the-ssh-transport-2m5c">packfiles</a> over the network to create your local and remote copies of the repository. This is inefficient for large files, resulting in slow uploads / downloads of data that is not text.</p>
<h1 id="sha-256-is-slow"><a class="header" href="#sha-256-is-slow">SHA-256 is Slow</a></h1>
<p>In order to tell if a file is changed, version control systems use a hashing function of the data. By default git uses SHA-256. This is a relatively slow hashing algorithm. By contrast Oxen uses a faster hashing algorithm called <a href="https://github.com/Cyan4973/xxHash">xxHash</a>. This results in hashing speeds of 31 GB/s for xxHash vs 0.8 GB/s of SHA-256.</p>
<p>The small change in hashing speeds results in an improvement in terms of developer experience when it comes to larger datasets.</p>
<p>If you want to see this in action, simply run <code>git add</code> on a large directory of data vs <code>oxen add</code> and see the difference in time.</p>
<h1 id="git-status-spews-all-files"><a class="header" href="#git-status-spews-all-files">Git Status Spews All Files</a></h1>
<p>Purely from Developer Experience this is not great. What if you add 100k images in a single commit? It's not practical to have git status show you all 100k files that are added.</p>
<p>With datasets we are dealing more with distributions of data, not individual data points.</p>
<h1 id="downloading-full-history"><a class="header" href="#downloading-full-history">Downloading Full History</a></h1>
<p>Git by default downloads the entire history of the repository on clone. When it comes to datasets, I may only want to download the latest version of a file, not the entire history.</p>
<p>Oxen gives you the flexibility to download just what you need at the time of training, inference, or testing.</p>
<h1 id="removing-objects"><a class="header" href="#removing-objects">Removing Objects</a></h1>
<p>Removing objects from git is a bit complex because of the references that are made through out the packfiles. Indices have to be recomputed and the history of the repository has to be rewritten if you want to remove a single file.</p>
<p>https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery</p>
<blockquote>
<p>There are a lot of great things about Git, but one feature that can cause issues is the fact that a git clone downloads the entire history of the project, including every version of every file. This is fine if the whole thing is source code, because Git is highly optimized to compress that data efficiently. However, if someone at any point in the history of your project added a single huge file, every clone for all time will be forced to download that large file, even if it was removed from the project in the very next commit. Because it‚Äôs reachable from the history, it will always be there.</p>
</blockquote>
<h1 id="packfiles"><a class="header" href="#packfiles">Packfiles</a></h1>
<p>One of the ways that git can save space is by using delta encoding to store only the differences between files. They do this through the use of <a href="https://dev.to/calebsander/git-internals-part-2-packfiles-1jg8">packfiles</a>. The objects are not stored directly in the objects directory rather packed up together in a packfile to make data transfer and compression easier.</p>
<p>Within a pack file there are multiple ways an object can be stored.</p>
<p>This is great for codebases, but not optimal for binary files.</p>
<h1 id="sources"><a class="header" href="#sources">Sources</a></h1>
<h3 id="git-scm-book"><a class="header" href="#git-scm-book">Git SCM book</a></h3>
<ul>
<li>https://git-scm.com/book/en/v2/Git-Internals-Maintenance-and-Data-Recovery</li>
</ul>
<h3 id="avoid-git-lfs-if-possible"><a class="header" href="#avoid-git-lfs-if-possible">Avoid Git-LFS if Possible</a></h3>
<ul>
<li>https://news.ycombinator.com/item?id=27134972</li>
<li>https://gregoryszorc.com/blog/2021/05/12/why-you-shouldn%27t-use-git-lfs/</li>
</ul>
<h3 id="devto-git-internals"><a class="header" href="#devto-git-internals">Dev.to git-internals</a></h3>
<ul>
<li>https://dev.to/calebsander/git-internals-part-2-packfiles-1jg8</li>
</ul>
<h3 id="pack-files"><a class="header" href="#pack-files">Pack files</a></h3>
<p>Git‚Äôs database internals I: packed object store</p>
<ul>
<li>https://github.blog/2022-08-29-gits-database-internals-i-packed-object-store/#delta-compression</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
